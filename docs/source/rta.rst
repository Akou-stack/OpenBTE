Relaxation time approximation
===================================


Within the temperature formulation, the BTE under th relaxation time approximation reads as

.. math::

   \mathbf{v}_\mu\cdot\nabla T_\mu^{(n)} + T_\mu^{(n)} = T_L

where

.. math::
    
   T_L = \left[ \sum_l \frac{C_l}{\tau_l} \right]^{-1} \sum_\nu \frac{C_\nu}{\tau_\nu} T_\nu.

The scattering times are defined as  :math:`\tau_\nu^{-1} = W_{\nu\nu}`, where :math:`\mathbf{W}` is the scattering matrix. Terms :math:`T_\mu`  are the phonon pseudo temperatures. Upon convergence, the heat flux is computed with :math:`\mathbf{J} = \mathcal{V}^{-1} N^{-1} \sum_\mu C_\mu \mathbf{v}_\mu T_\mu`, where :math:`\mathbf{v}_\mu` is the group velocity and :math:`C_\mu` is the heat capacity; the latter is defined as :math:`C_\mu = k_B \eta_\mu \left(\sinh \eta_\mu \right)^{-2}`, where :math:`\eta_\mu = \hbar \omega_\mu/k_B/T_0/2`. Adiabatic boundary conditions are generally applied with :math:`T_{\mu^-} = \sum_{\nu^+} R_{\mu^-\nu^+} T_{\nu^+}`, where :math:`R_{\mu^-\nu^+}` is a reflection matrix, :math:`T_{\mu^-}` (:math:`T_{\mu^+}`) is related to incoming (outgoing) phonons. Currently, OpenBTE employes a crude approximation, i.e. all phonons thermalize to a boundary temperature, whose values is obtained by ensuring zero total incident flux [`Landon (2014)`_]. Within this approach, the reflection matrix reads as :math:`R_{\mu^-\nu^+}=-C_\nu\mathbf{v}_\nu \cdot \hat{\mathbf{n}} \left[\sum_{k^-} C_{k^-} \mathbf{v}_{k^-}\cdot \hat{\mathbf{n}} \right]^{-1}`.

Creating ``rta.h5``
###############################################

The first step for solving the RTA-BTE is to create the file ``rta.h5``. This file is an ``hdf5`` file that must have the following items:

.. table:: 
   :widths: auto
   :align: center

   +----------------+-------------+--------------------------------------------------------------------------+--------------------------+
   | **Item**       | **Shape**   |       **Symbol [Units]**                                                 |    **Name**              |
   +----------------+-------------+--------------------------------------------------------------------------+--------------------------+
   | ``tau``        |  N          |   :math:`\tau` [:math:`s`]                                               | Scattering time          |
   +----------------+-------------+--------------------------------------------------------------------------+--------------------------+
   | ``C``          |  N          |   :math:`C` [:math:`\mathrm{W}\mathrm{s}\textrm{K}^{-1}\textrm{m}^{-3}`] | Specific Heat capacity   |
   +----------------+-------------+--------------------------------------------------------------------------+--------------------------+
   | ``v``          |  N x 3      |   :math:`\mathbf{v}` [:math:`\mathrm{m}\textrm{s}^{-1}`]                 | Group velocity           |
   +----------------+-------------+--------------------------------------------------------------------------+--------------------------+
   | ``kappa``      |  3 x 3      |   :math:`\kappa` [:math:`\mathrm{W}\textrm{K}^{-1}\textrm{m}^{-1}`]      | Thermal conductivity     |
   +----------------+-------------+--------------------------------------------------------------------------+--------------------------+


Each item must be a ``numpy`` array with the prescribed ``shape``. We recommend using the package Deepdish_ for IO ``hdf5`` operations. The thermal conductivity tensor is given by :math:`\kappa^{\alpha\beta} = \mathcal{V}^{-1}N^{-1}\sum_{\mu} C_\mu  v_\mu^{\alpha} v_\mu^{\beta} \tau_\mu`, where :math:`\mathcal{V}` is the volume of the unit cell and :math:`N` is the numbre of wave vectors. To check the consistencty of the data populating ``rta.h5``, you may want to run this script:

.. code-block:: python

   import numpy as np
   import deepdish as dd

   data = dd.io.load('rta.h5')
   kappa = data['alpha']*np.einsum('k,ki,kj,k->ij',data['C'],data['v'],data['v'],data['tau'])

   assert(np.allclose(kappa,data['kappa']))

Of course, the best practice is to have the ``kappa`` populating ``rta.h5`` generated by the other items and compare it with the intended value.


Two-dimensional materials
###############################################

For two-dimensional materials, a thickness :math:`L_c` is used for first-principles calculations. When reporting the thermal conductivity, however, and effective thickness, :math:`h`, is used. In practice, the volume of the unit cell must be computed as :math:`\mathcal{V} = \mathcal{V}_{\mathrm{DFT}} L_c/h`, where :math:`\mathcal{V}_{\mathrm{DFT}}` is the volume of the unit-cell used in DFT calculations [`Wu et al.`_]. This band-aid solution is often used to compare thermal conductivities of 2D and 3D materials. 

Creating ``material.f5``
###############################################

With ``rta.h5`` in your current directory, ``material.h5`` can be generated simply with

.. code-block:: python

   Material(model='rta',submodel=<('3D'),'2DSym','2D'>)

The ``Material`` object will perform MFP interpolation. In fact, due to the fact that :math:`T_{\mu}` is a smooth function of :math:`\mathbf{v}_\mu \tau_mu`, the BTE can be cast into

:math:`\mathbf{F}_k \cdot \nabla T_k + T_k = \sum_{k'} a_{k'} T_{k'}`,

where :math:`\mathbf{F}_k` uniformnly span a sphere or a disk, depending on our problem. The coefficients :math:`a_{k'}` arise from the linear interpolation. As outlined below, submodels (specified with ``submodel``) may enhance computational efficiency.


.. tabs::

   .. tab:: ``submodel='3D'``

    This is the case where an actual 3D simulation is performed. The coefficients are:
     
    +------------------------------------------------------------------------------------------------------------------------------------------------------------+
    | :math:`\mathbf{F}_k = \Lambda_k (\sin{\phi_k}\sin{\theta_k}\mathbf{\hat{x}} +\cos{\phi_k}\sin{\theta_k}\mathbf{\hat{y}} +\cos\theta_k \mathbf{\hat{z}} )`  | 
    +------------------------------------------------------------------------------------------------------------------------------------------------------------+
    | :math:`\alpha_k = \left[\sum_l  C_l/\tau_l \right]^{-1} \sum_\mu \mathcal{M}(\mathbf{v}_\mu \tau_\mu,\mathbf{F}_{k}) C_\mu/\tau_{\mu}`                     | 
    +------------------------------------------------------------------------------------------------------------------------------------------------------------+
    | :math:`\mathbf{G}_k = \sum_\mu \mathcal{M}(\mathbf{v}_\mu \tau_\mu,\mathbf{F}_{k}) C_\mu \mathbf{v}_\mu`                                                   | 
    +------------------------------------------------------------------------------------------------------------------------------------------------------------+
  

   .. tab:: ``submodel='2DSym'``

    This is the case where the simulation domain has translational invariance along :math:`z`. In this case each bulk MFP :math:`\mathbf{v}_\mu\tau_\mu` can be mapped onto the :math:`z=0` plane. 

    +-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    | :math:`\mathbf{F}_k = \chi_k (\sin{\phi_k}\mathbf{\hat{x}} +\cos{\phi_k}\mathbf{\hat{y}})`                                                                                                                                        | 
    +-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    | :math:`\alpha_k = \left[\sum_l  C_l/\tau_l \right]^{-1} \sum_\mu \left[\mathcal{M}( \mathbf{S}_z\mathbf{v}_\mu \tau_\mu,\mathbf{F}_{k}) + \delta(\mathbf{v}_\mu\cdot\mathbf{\hat{z}}-|\mathbf{v}_\mu|)   \right] C_\mu/\tau_\mu`  |  
    +-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    | :math:`\mathbf{G}_k = \sum_\mu \mathcal{M}(\mathbf{v}_\mu^{\mathrm{2D}} \tau_\mu,\mathbf{F}_{k}) C_\mu \mathbf{v}_\mu`                                                                                                            | 
    +-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
  
    where :math:`\mathbf{S}_z` is a projection operator onto the plane :math:`z=0`.


   .. tab:: ``submodel='2D'``

    An actual 2D material is being simulated. 

    +------------------------------------------------------------------------------------------------------------------------------------------------------------+
    | :math:`\mathbf{F}_k = \Lambda_k (\sin{\phi_k}\mathbf{\hat{x}} +\cos{\phi_k}\mathbf{\hat{y}})`                                                              | 
    +------------------------------------------------------------------------------------------------------------------------------------------------------------+
    | :math:`\alpha_k = \left[\sum_l  C_l/\tau_l \right]^{-1} \sum_\mu \mathcal{M}(\mathbf{v}_\mu \tau_\mu,\mathbf{F}_{k}) C_\mu/\tau_\mu`                       |      
    +------------------------------------------------------------------------------------------------------------------------------------------------------------+
    | :math:`\mathbf{G}_k = \sum_\mu \mathcal{M}(\mathbf{v}_\mu \tau_\mu,\mathbf{F}_{k}) C_\mu \mathbf{v}_\mu`                                                   | 
    +------------------------------------------------------------------------------------------------------------------------------------------------------------+

Interface with AlmaBTE
###############################################

AlmaBTE_ is a popular package that compute the thermal conductivity of bulk materials, thin films and superlattices. OpenBTE is interfaced with AlmaBTE for RTA calculations via the script ``almabte2openbte.py``. 

Assuming you have ``AlmaBTE`` in your current ``PATH``, this an example for ``Si``.

- Download Silicon force constants from AlmaBTE's database_.

  .. code-block:: bash

   https://almabte.bitbucket.io/database/Si.tar.xz   
   tar -xf Si.tar.xz && rm -rf Si.tar.xz  

- Compute bulk scattering time with AlmaBTE.

  .. code-block:: bash

   echo "<singlecrystal> 
   <compound name='Si'/>
   <gridDensity A='8' B='8' C='8'/>
   </singlecrystal>" > inputfile.xml
   
   VCAbuilder inputfile.xml
   phononinfo Si/Si_8_8_8.h5
    
- A file named ``Si_8_8_8_300K.phononinfo`` is in your current directory. The file ``rta.h5`` can then be created with 

  .. code-block:: bash

     AlmaBTE2OpenBTE Si_8_8_8_300K.phononinfo


.. _Deepdish: https://deepdish.readthedocs.io/
.. _`Wu et al.`: https://www.sciencedirect.com/science/article/pii/S0009261416310193?via%3Dihub
.. _`Fugallo et al. (2013)`: https://arxiv.org/pdf/1212.0470.pdf
.. _`Romano (2020)`: https://arxiv.org/abs/2002.08940
.. _Phono3py: https://phonopy.github.io/phono3py/
.. _`Chaput (2013)`: https://journals.aps.org/prl/pdf/10.1103/PhysRevLett.110.265506?casa_token=BTUhHjniziYAAAAA%3AGw4C_2ql3cGvy6zwNe_38m7vz130fV7LYZMxrnIt_FSbmQauL3fczg5QT1b0EXTU39nYWEHYUHbv
.. _`Landon (2014)`: https://dspace.mit.edu/handle/1721.1/92161
.. _`Vazrik et al. (2017)` : https://arxiv.org/pdf/1711.07151.pdf
.. _`Cepellotti et al. (2016)` : https://journals.aps.org/prx/abstract/10.1103/PhysRevX.6.041013
.. _AlmaBTE: https://almabte.bitbucket.io/
.. _database: https://almabte.bitbucket.io/database/



